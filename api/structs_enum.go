// Code generated by go-enum DO NOT EDIT.
// Version: 0.5.4
// Revision: 9793817a5b65af692253b8bc6081fe69a4b6985f
// Build Date: 2022-12-21T19:29:50Z
// Built By: goreleaser

package api

import (
	"fmt"
	"strings"
)

const (
	// FileTypeAll is a FileType of type All.
	FileTypeAll FileType = iota
	// FileTypeArchive is a FileType of type Archive.
	FileTypeArchive
	// FileTypeMobile is a FileType of type Mobile.
	FileTypeMobile
	// FileTypeEbook is a FileType of type Ebook.
	FileTypeEbook
	// FileTypeAudio is a FileType of type Audio.
	FileTypeAudio
	// FileTypeVideo is a FileType of type Video.
	FileTypeVideo
)

var ErrInvalidFileType = fmt.Errorf("not a valid FileType, try [%s]", strings.Join(_FileTypeNames, ", "))

const _FileTypeName = "AllArchiveMobileEbookAudioVideo"

var _FileTypeNames = []string{
	_FileTypeName[0:3],
	_FileTypeName[3:10],
	_FileTypeName[10:16],
	_FileTypeName[16:21],
	_FileTypeName[21:26],
	_FileTypeName[26:31],
}

// FileTypeNames returns a list of possible string values of FileType.
func FileTypeNames() []string {
	tmp := make([]string, len(_FileTypeNames))
	copy(tmp, _FileTypeNames)
	return tmp
}

var _FileTypeMap = map[FileType]string{
	FileTypeAll:     _FileTypeName[0:3],
	FileTypeArchive: _FileTypeName[3:10],
	FileTypeMobile:  _FileTypeName[10:16],
	FileTypeEbook:   _FileTypeName[16:21],
	FileTypeAudio:   _FileTypeName[21:26],
	FileTypeVideo:   _FileTypeName[26:31],
}

// String implements the Stringer interface.
func (x FileType) String() string {
	if str, ok := _FileTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("FileType(%d)", x)
}

var _FileTypeValue = map[string]FileType{
	_FileTypeName[0:3]:                    FileTypeAll,
	strings.ToLower(_FileTypeName[0:3]):   FileTypeAll,
	_FileTypeName[3:10]:                   FileTypeArchive,
	strings.ToLower(_FileTypeName[3:10]):  FileTypeArchive,
	_FileTypeName[10:16]:                  FileTypeMobile,
	strings.ToLower(_FileTypeName[10:16]): FileTypeMobile,
	_FileTypeName[16:21]:                  FileTypeEbook,
	strings.ToLower(_FileTypeName[16:21]): FileTypeEbook,
	_FileTypeName[21:26]:                  FileTypeAudio,
	strings.ToLower(_FileTypeName[21:26]): FileTypeAudio,
	_FileTypeName[26:31]:                  FileTypeVideo,
	strings.ToLower(_FileTypeName[26:31]): FileTypeVideo,
}

// ParseFileType attempts to convert a string to a FileType.
func ParseFileType(name string) (FileType, error) {
	if x, ok := _FileTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _FileTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return FileType(0), fmt.Errorf("%s is %w", name, ErrInvalidFileType)
}

// Set implements the Golang flag.Value interface func.
func (x *FileType) Set(val string) error {
	v, err := ParseFileType(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *FileType) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *FileType) Type() string {
	return "FileType"
}

const (
	// SortTypeDateDESC is a SortType of type DateDESC.
	SortTypeDateDESC SortType = iota
	// SortTypeDateASC is a SortType of type DateASC.
	SortTypeDateASC
	// SortTypeSizeDESC is a SortType of type SizeDESC.
	SortTypeSizeDESC
	// SortTypeSizeASC is a SortType of type SizeASC.
	SortTypeSizeASC
	// SortTypeFileDESC is a SortType of type FileDESC.
	SortTypeFileDESC
	// SortTypeFileASC is a SortType of type FileASC.
	SortTypeFileASC
)

var ErrInvalidSortType = fmt.Errorf("not a valid SortType, try [%s]", strings.Join(_SortTypeNames, ", "))

const _SortTypeName = "DateDESCDateASCSizeDESCSizeASCFileDESCFileASC"

var _SortTypeNames = []string{
	_SortTypeName[0:8],
	_SortTypeName[8:15],
	_SortTypeName[15:23],
	_SortTypeName[23:30],
	_SortTypeName[30:38],
	_SortTypeName[38:45],
}

// SortTypeNames returns a list of possible string values of SortType.
func SortTypeNames() []string {
	tmp := make([]string, len(_SortTypeNames))
	copy(tmp, _SortTypeNames)
	return tmp
}

var _SortTypeMap = map[SortType]string{
	SortTypeDateDESC: _SortTypeName[0:8],
	SortTypeDateASC:  _SortTypeName[8:15],
	SortTypeSizeDESC: _SortTypeName[15:23],
	SortTypeSizeASC:  _SortTypeName[23:30],
	SortTypeFileDESC: _SortTypeName[30:38],
	SortTypeFileASC:  _SortTypeName[38:45],
}

// String implements the Stringer interface.
func (x SortType) String() string {
	if str, ok := _SortTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("SortType(%d)", x)
}

var _SortTypeValue = map[string]SortType{
	_SortTypeName[0:8]:                    SortTypeDateDESC,
	strings.ToLower(_SortTypeName[0:8]):   SortTypeDateDESC,
	_SortTypeName[8:15]:                   SortTypeDateASC,
	strings.ToLower(_SortTypeName[8:15]):  SortTypeDateASC,
	_SortTypeName[15:23]:                  SortTypeSizeDESC,
	strings.ToLower(_SortTypeName[15:23]): SortTypeSizeDESC,
	_SortTypeName[23:30]:                  SortTypeSizeASC,
	strings.ToLower(_SortTypeName[23:30]): SortTypeSizeASC,
	_SortTypeName[30:38]:                  SortTypeFileDESC,
	strings.ToLower(_SortTypeName[30:38]): SortTypeFileDESC,
	_SortTypeName[38:45]:                  SortTypeFileASC,
	strings.ToLower(_SortTypeName[38:45]): SortTypeFileASC,
}

// ParseSortType attempts to convert a string to a SortType.
func ParseSortType(name string) (SortType, error) {
	if x, ok := _SortTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _SortTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return SortType(0), fmt.Errorf("%s is %w", name, ErrInvalidSortType)
}

// Set implements the Golang flag.Value interface func.
func (x *SortType) Set(val string) error {
	v, err := ParseSortType(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *SortType) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *SortType) Type() string {
	return "SortType"
}
